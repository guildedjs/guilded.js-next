import { Member, PartialMember } from "guilded.js";
import { isHashId } from "../../utils/uuid";
import type { CommandArgumentValidator } from "../ArgumentParser";

export default {
	validate: async ({ input, mentionCounters, message, rawArgs, argIndex }) => {
		if (input.startsWith("@")) {
			const mention = message.mentions?.users?.[mentionCounters.users++];
			if (!mention) return { error: true, reason_code: "NO_USER_IN_MENTIONS" };

			const member = await message.client.members.fetch(message.serverId!, mention.id).catch(() => null);
			if (!member) return { error: true, reason_code: "MEMBER_NOT_FOUND" };

			const name = member.username ?? member.nickname ?? member.displayName;
			const spaceCount = name!.split(" ").length;
			rawArgs.splice(argIndex + 1, spaceCount - 1);
			rawArgs[argIndex] = name!;

			return {
				error: false,
				argument: normalizeMember(member),
			};
		}

		if (isHashId(input)) {
			const member = await message.client.members
				.fetch(message.serverId!, input)
				.then(normalizeMember)
				.catch(() => {
					return new PartialMember(message.client, {
						id: input,
						serverId: message.serverId!,
						roleIds: [],
						user: {
							id: input,
							name: "Unknown User (generated by Bot)",
						},
					});
				});

			if (!member) return { error: true, reason_code: "MEMBER_NOT_FOUND" };

			return { error: false, argument: member };
		}

		return { error: true, reason_code: "INVALID_MEMBER_INPUT" };
	},
} satisfies CommandArgumentValidator;

function normalizeMember(member: Member): PartialMember {
	return new PartialMember(member.client, {
		id: member.id,
		serverId: member.serverId!,
		roleIds: member.roleIds,
		user: {
			id: member.id,
			name: member.username ?? member.nickname ?? member.displayName!,
		},
	});
}
